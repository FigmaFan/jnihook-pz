#include "classfile.hpp"
#include <cassert>
#include <iostream>
#include <vector>

// Minimal Java class compiled from:
//   public class Simple {
//       public int value;
//       public void hello() {}
//   }
// The class file was compiled with javac and the bytes are embedded
// here to exercise the ClassFile parser.
static const uint8_t simple_class[] = {
    0xca, 0xfe, 0xba, 0xbe, 0x00, 0x00, 0x00, 0x41, 0x00, 0x10, 0x0a, 0x00, 0x02, 0x00, 0x03, 0x07,
    0x00, 0x04, 0x0c, 0x00, 0x05, 0x00, 0x06, 0x01, 0x00, 0x10, 0x6a, 0x61, 0x76, 0x61, 0x2f, 0x6c,
    0x61, 0x6e, 0x67, 0x2f, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x01, 0x00, 0x06, 0x3c, 0x69, 0x6e,
    0x69, 0x74, 0x3e, 0x01, 0x00, 0x03, 0x28, 0x29, 0x56, 0x07, 0x00, 0x08, 0x01, 0x00, 0x06, 0x53,
    0x69, 0x6d, 0x70, 0x6c, 0x65, 0x01, 0x00, 0x05, 0x76, 0x61, 0x6c, 0x75, 0x65, 0x01, 0x00, 0x01,
    0x49, 0x01, 0x00, 0x04, 0x43, 0x6f, 0x64, 0x65, 0x01, 0x00, 0x0f, 0x4c, 0x69, 0x6e, 0x65, 0x4e,
    0x75, 0x6d, 0x62, 0x65, 0x72, 0x54, 0x61, 0x62, 0x6c, 0x65, 0x01, 0x00, 0x05, 0x68, 0x65, 0x6c,
    0x6c, 0x6f, 0x01, 0x00, 0x0a, 0x53, 0x6f, 0x75, 0x72, 0x63, 0x65, 0x46, 0x69, 0x6c, 0x65, 0x01,
    0x00, 0x0b, 0x53, 0x69, 0x6d, 0x70, 0x6c, 0x65, 0x2e, 0x6a, 0x61, 0x76, 0x61, 0x00, 0x21, 0x00,
    0x07, 0x00, 0x02, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x09, 0x00, 0x0a, 0x00, 0x00, 0x00,
    0x02, 0x00, 0x01, 0x00, 0x05, 0x00, 0x06, 0x00, 0x01, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x1d, 0x00,
    0x01, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x2a, 0xb7, 0x00, 0x01, 0xb1, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x0c, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x0d,
    0x00, 0x06, 0x00, 0x01, 0x00, 0x0b, 0x00, 0x00, 0x00, 0x19, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
    0x00, 0x01, 0xb1, 0x00, 0x00, 0x00, 0x01, 0x00, 0x0c, 0x00, 0x00, 0x00, 0x06, 0x00, 0x01, 0x00,
    0x00, 0x00, 0x03, 0x00, 0x01, 0x00, 0x0e, 0x00, 0x00, 0x00, 0x02, 0x00, 0x0f,
};

// Helper to resolve a UTF-8 string from the constant pool.
static std::string utf8_at(ClassFile &cf, u2 index)
{
    auto &cpi = cf.get_constant_pool_item(index);
    auto info = reinterpret_cast<CONSTANT_Utf8_info *>(cpi.bytes.data());
    return std::string(reinterpret_cast<char *>(info->bytes), info->length);
}

int main()
{
    auto cf = ClassFile::load(simple_class);
    assert(cf && "Failed to parse valid class");

    // Validate field table
    auto &fields = cf->get_fields();
    assert(fields.size() == 1);
    auto field_name = utf8_at(*cf, fields[0].name_index);
    auto field_desc = utf8_at(*cf, fields[0].descriptor_index);
    assert(field_name == "value");
    assert(field_desc == "I");

    // Validate method table
    auto &methods = cf->get_methods();
    assert(methods.size() == 2); // <init> and hello
    auto method_name = utf8_at(*cf, methods[1].name_index);
    auto method_desc = utf8_at(*cf, methods[1].descriptor_index);
    assert(method_name == "hello");
    assert(method_desc == "()V");

    // Introduce malformed data (wrong magic) and ensure parser fails
    std::vector<uint8_t> bad(simple_class, simple_class + sizeof(simple_class));
    bad[0] = 0x00; // Break magic number
    auto bad_cf = ClassFile::load(bad.data());
    assert(!bad_cf && "Parser should reject invalid magic");

    std::cout << "ClassFile parsing tests passed" << std::endl;
    return 0;
}

